from PyQt5.QtCore import *
from PyQt5.QtWidgets import *
from PyQt5.QtGui import QColor
import sys
import random

def game_area_str(matrix: list[list]):
    game_area_str = ''
    for i in range(4):
        output_string = ''
        for j in range(4):
            output_string += '['+ str(matrix[i][j]) + '] '
        game_area_str += output_string + "\n"
    return game_area_str

def have_space(matrix: list[list]):
    for i in range(4):
        for j in range(4):
            if matrix[i][j] == 0:
                return True
            
def addtile(matrix: list[list]):
    if have_space(matrix):
        c, r = random.randint(0, 3), random.randint(0, 3)
        while matrix[r][c] != 0:
            c, r = random.randint(0, 3), random.randint(0, 3)
        if random.randint(1, 10) == 1:
            tilevalue = 4
        else:
            tilevalue = 2
        matrix[r][c] = tilevalue

def get_state(matrix: list[list]):
    if have_space(matrix):
        return "CON"
    for i in range(3):
        for j in range(3):
            if matrix[i][j] == matrix[i][j + 1] or matrix[i][j] == matrix[i + 1][j]:
                return "CON"
            elif matrix[3][j] == matrix[3][j + 1] or matrix[i][3] == matrix[i + 1][3]:
                return "CON"
    for i in range(4):
        for j in range(4):
            if matrix[i][j] == 2048:
                return 'WIN'
    return "LUS"

def rotated_right(matrix: list[list]):
    rmatrix = [[], [], [], []]
    for i in range(4):
        for j in range(4):
            rmatrix[i].append(matrix[-1 - j][i])
    return rmatrix

def rotated_left(matrix: list[list]):
    rmatrix = [[], [], [], []]
    for i in range(4):
        for j in range(4):
            rmatrix[i].append(matrix[j][-1 - i])
    return rmatrix

def moved_left(matrix: list[list]):
    global score
    global merge_cnt
    new_matrix = matrix
    for i in range(4):
        l = 0
        r = 1
        while r != 4:
            if new_matrix[i][l] != 0:
                l += 1
                r += 1
            elif new_matrix[i][r] == 0:
                r += 1
            else:
                new_matrix[i][l] = new_matrix[i][r]
                new_matrix[i][r] = 0
                l += 1
                r += 1
        for j in range(3):
            if new_matrix[i][j] == new_matrix[i][j + 1] and new_matrix[i][j] != 0:
                new_matrix[i][j] *= 2
                score += new_matrix[i][j]
                merge_cnt += 1
                new_matrix[i][j + 1] = 0
    for i in range(4):
        l = 0
        r = 1
        while r != 4:
            if new_matrix[i][l] != 0:
                l += 1
                r += 1
            elif new_matrix[i][r] == 0:
                r += 1
            else:
                new_matrix[i][l] = new_matrix[i][r]
                new_matrix[i][r] = 0
                l += 1
                r += 1
    return new_matrix

def moved_right(matrix: list[list]):
    return rotated_left(rotated_left(moved_left(rotated_right(rotated_right(matrix)))))

def moved_down(matrix: list[list]):
    return rotated_left(moved_left(rotated_right(matrix)))

def moved_up(matrix: list[list]):
    return rotated_right(moved_left(rotated_left(matrix)))

score = 0
merge_cnt = 0

class MainWindow(QWidget):
    def __init__(self):
        tile_color = QColor(242, 226, 194).name()
        bg_plain_color = QColor(232, 217, 186).name()
        super().__init__()
        self.tilesize = 150
        self.matrix = QLabel(self)
        self.score_table = QLabel(self)
        self.score_font = self.score_table.font()
        self.score_font.setPointSize(30)
        self.score_table.setFont(self.score_font)
        self.game_area, self.game_area_pos = [[0, 0, 0, 0],
                                              [0, 0, 0, 0],
                                              [0, 0, 0, 0],
                                              [0, 0, 0, 0]], [[[], [], [], []],
                                                              [[], [], [], []],
                                                              [[], [], [], []],
                                                              [[], [], [], []]]

        self.tileposy = 275
        for i in range(4):
            self.tileposx = 635
            self.tileposy += 10
            if i > 0:
                self.tileposy += self.tilesize
            for j in range(4):
                self.tileposx += 10
                if j > 0:
                    self.tileposx += self.tilesize                
                self.game_area_pos[i][j].append(self.tileposx)
                self.game_area_pos[i][j].append(self.tileposy)

        addtile(self.game_area)
        addtile(self.game_area)
        self.matrix.setText(game_area_str(self.game_area))

        self.score_table.setGeometry(810, 150, 300, 150)
        self.score_table.setAlignment(Qt.AlignHCenter | Qt.AlignVCenter)
        self.score_table.setStyleSheet("background-color: %s; border-radius: 30px" % bg_plain_color)
        self.score_table.setText("cчёт: 0")

        self.bg_plain = QWidget(self)
        self.bg_plain.setStyleSheet("background-color: %s; border-radius: 30px" % bg_plain_color)
        self.bg_plain.setGeometry(635, 275, 650, 650)

        self.tile1, self.tile2, self.tile3, self.tile4 = QWidget(self), QWidget(self), QWidget(self), QWidget(self)
        self.tile5, self.tile6, self.tile7, self.tile8 = QWidget(self), QWidget(self), QWidget(self), QWidget(self)      
        self.tile9, self.tile10, self.tile11, self.tile12 = QWidget(self), QWidget(self), QWidget(self), QWidget(self)
        self.tile13, self.tile14, self.tile15, self.tile16 = QWidget(self), QWidget(self), QWidget(self), QWidget(self)

        self.tiles_lst = [[[self.tile1, [0, 0], True], [self.tile2, [0, 1], True], [self.tile3, [0, 2], True], [self.tile4, [0, 3], True]], 
                           [[self.tile5, [1, 0], True], [self.tile6, [1, 1], False], [self.tile7, [1, 2], False], [self.tile8, [1, 3], False]],
                           [[self.tile9, [2, 0], True], [self.tile10, [2, 1], False], [self.tile11, [2, 2], False], [self.tile12, [2, 3], False]],
                           [[self.tile13, [3, 0], True], [self.tile14, [3, 1], False], [self.tile15, [3, 2], False], [self.tile16, [3, 3], False]]]
        for i in range(4):
            for j in range(4):
                self.tiles_lst[i][j][0].setStyleSheet("background-color: %s; border-radius: 10px" % tile_color)
                self.tiles_lst[i][j][0].setGeometry(self.game_area_pos[i][j][0], self.game_area_pos[i][j][1], self.tilesize, self.tilesize)
        self.setWindowTitle("2048")
        self.setMinimumSize(960, 600)
        self.showMaximized()
        self.setWindowFlag(Qt.FramelessWindowHint)
        self.show()

    def keyPressEvent(self, e):
        global score
        self.pos_anim = QParallelAnimationGroup()

        if e.key() == Qt.Key_Q:
            self.close()
        
        if e.key() == Qt.Key_D:
            if self.game_area != moved_right(self.game_area):
                self.game_area = moved_right(self.game_area)
                addtile(self.game_area)
            for i in range(4):
                for j in range(4):
                    if self.tiles_lst[i][j][2] and not self.tiles_lst[i][j][1][1] == 3:
                        self.tiles_lst[i][j][1][1] += 1
                        for r in range(4):
                            for c in range(4):
                                if i == r and j == c:
                                    continue
                                if not (self.tiles_lst[i][j][1][0] == self.tiles_lst[r][c][1][0] and self.tiles_lst[r][c][2]):
                                    continue
                                if self.tiles_lst[i][j][1][1] == self.tiles_lst[r][c][1][1] or self.tiles_lst[i][j][1][1] == 4:
                                    self.tiles_lst[i][j][1][1] -= 1
                                    break
                            else:
                                continue
                            break
                        self.anim = QPropertyAnimation(self.tiles_lst[i][j][0], b"pos")
                        self.anim.setEasingCurve(QEasingCurve.OutCubic)
                        self.anim.setDuration(300)
                        self.pos_anim.addAnimation(self.anim)
                        self.anim.setEndValue(QPoint(self.game_area_pos[self.tiles_lst[i][j][1][0]][self.tiles_lst[i][j][1][1]][0], self.game_area_pos[self.tiles_lst[i][j][1][0]][self.tiles_lst[i][j][1][1]][1]))


        if e.key() == Qt.Key_A:
            self.game_area = moved_left(self.game_area)
            addtile(self.game_area)
            for i in range(4):
                for j in range(4):
                    if self.tiles_lst[i][j][2] and not self.tiles_lst[i][j][1][1] == 0:
                        self.tiles_lst[i][j][1][1] -= 1
                        for r in range(4):
                            for c in range(4):
                                if i == r and j == c:
                                    continue                                
                                if not (self.tiles_lst[i][j][1][0] == self.tiles_lst[r][c][1][0] and self.tiles_lst[r][c][2]):     
                                    continue
                                if self.tiles_lst[i][j][1][1] == self.tiles_lst[r][c][1][1] or self.tiles_lst[i][j][1][1] == -1:
                                    self.tiles_lst[i][j][1][1] += 1
                                    break
                            else:
                                continue
                            break
                        self.anim = QPropertyAnimation(self.tiles_lst[i][j][0], b"pos")
                        self.anim.setEasingCurve(QEasingCurve.OutCubic)
                        self.anim.setDuration(300)
                        self.pos_anim.addAnimation(self.anim)
                        self.anim.setEndValue(QPoint(self.game_area_pos[self.tiles_lst[i][j][1][0]][self.tiles_lst[i][j][1][1]][0], self.game_area_pos[self.tiles_lst[i][j][1][0]][self.tiles_lst[i][j][1][1]][1]))

        if e.key() == Qt.Key_W:
            if self.game_area != moved_up(self.game_area):
                self.game_area = moved_up(self.game_area)
                addtile(self.game_area)
            for i in range(4):
                for j in range(4):
                    if self.tiles_lst[i][j][2] and not self.tiles_lst[i][j][1][0] == 0:
                        self.tiles_lst[i][j][1][0] -= 1
                        for r in range(4):
                            for c in range(4):
                                if i == r and j == c:
                                    continue
                                if not (self.tiles_lst[i][j][1][1] == self.tiles_lst[r][c][1][1] and self.tiles_lst[r][c][2]):
                                    continue
                                if self.tiles_lst[i][j][1][0] == self.tiles_lst[r][c][1][0] or self.tiles_lst[i][j][1][0] == -1:
                                    self.tiles_lst[i][j][1][0] += 1
                                    break
                            else:
                                continue
                            break
                        self.anim = QPropertyAnimation(self.tiles_lst[i][j][0], b"pos")
                        self.anim.setEasingCurve(QEasingCurve.OutCubic)
                        self.anim.setDuration(300)
                        self.pos_anim.addAnimation(self.anim)
                        self.anim.setEndValue(QPoint(self.game_area_pos[self.tiles_lst[i][j][1][0]][self.tiles_lst[i][j][1][1]][0], self.game_area_pos[self.tiles_lst[i][j][1][0]][self.tiles_lst[i][j][1][1]][1]))

        if e.key() == Qt.Key_S:
            if self.game_area != moved_down(self.game_area):
                self.game_area = moved_down(self.game_area)
                addtile(self.game_area)
            for i in range(4):
                for j in range(4):
                    if self.tiles_lst[i][j][2] and not self.tiles_lst[i][j][1][0] == 3:
                        self.tiles_lst[i][j][1][0] += 1
                        for r in range(4):
                            for c in range(4):
                                if i == r and j == c:
                                    continue
                                if not (self.tiles_lst[i][j][1][1] == self.tiles_lst[r][c][1][1] and self.tiles_lst[r][c][2]):
                                    continue
                                if self.tiles_lst[i][j][1][0] == self.tiles_lst[r][c][1][0] or self.tiles_lst[i][j][1][0] == 4:
                                    self.tiles_lst[i][j][1][0] -= 1
                                    break
                            else:
                                continue
                            break
                        self.anim = QPropertyAnimation(self.tiles_lst[i][j][0], b"pos")
                        self.anim.setEasingCurve(QEasingCurve.OutCubic)
                        self.anim.setDuration(300)
                        self.pos_anim.addAnimation(self.anim)
                        self.anim.setEndValue(QPoint(self.game_area_pos[self.tiles_lst[i][j][1][0]][self.tiles_lst[i][j][1][1]][0], self.game_area_pos[self.tiles_lst[i][j][1][0]][self.tiles_lst[i][j][1][1]][1]))
        
        self.pos_anim.start()
        self.matrix.setText(game_area_str(self.game_area))
        self.score_table.setText("cчёт: " + str(score))

app = QApplication(sys.argv)
window_game = MainWindow()
sys.exit(app.exec_())
